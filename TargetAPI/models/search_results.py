# generated by datamodel-codegen:
#   filename:  data.json
#   timestamp: 2022-08-27T23:48:21+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional

from pydantic import BaseModel


class Detail(BaseModel):
    display_name: str
    url: str
    value: str
    facet_id: Optional[str] = None


class Option(BaseModel):
    display_name: str
    url: str
    value: str
    id: Optional[str] = None


class FacetListItem(BaseModel):
    name: str
    facet_id: str
    type: str
    display_name: str
    expand: bool
    details: List[Detail]
    options: List[Option]


class Metadata(BaseModel):
    response_ids: List[str]


class TypedMetadata(BaseModel):
    count: int
    current_page: int
    keyword: str
    offset: int
    sort_by: str
    total_pages: int
    total_results: int


class SortOption(BaseModel):
    name: str
    value: str


class SearchResponse(BaseModel):
    facet_list: List[FacetListItem]
    metadata: Metadata
    typed_metadata: TypedMetadata
    sort_options: List[SortOption]


class MerchandiseClassification(BaseModel):
    class_id: int
    department_id: int


class Images(BaseModel):
    primary_image_url: str
    alternate_image_urls: List[str]


class VideoFile(BaseModel):
    mime_type: str
    video_url: str


class Video(BaseModel):
    is_list_page_eligible: bool
    video_files: List[VideoFile]


class Enrichment(BaseModel):
    buy_url: str
    images: Images
    videos: Optional[List[Video]] = None


class SoftBullets(BaseModel):
    bullets: List[str]


class ProductDescription(BaseModel):
    title: str
    bullet_descriptions: List[str]
    soft_bullets: SoftBullets


class ProductVendor(BaseModel):
    vendor_name: str
    id: str


class PrimaryBrand(BaseModel):
    canonical_url: str
    facet_id: str
    linking_id: str
    name: str


class Item(BaseModel):
    relationship_type: str
    relationship_type_code: str
    merchandise_classification: MerchandiseClassification
    eligibility_rules: Optional[Dict[str, Any]] = None
    enrichment: Enrichment
    compliance: Dict[str, Any]
    dpci: str
    cart_add_on_threshold: float
    product_description: ProductDescription
    product_vendors: List[ProductVendor]
    fulfillment: Dict[str, Any]
    primary_brand: PrimaryBrand


class Promotion(BaseModel):
    plp_message: str
    promotion_id: str
    promotion_class: str
    subscription_type: str
    threshold_type: str
    threshold_value: float
    reward_type: str
    reward_value: float
    circle_offer: bool


class Price(BaseModel):
    formatted_current_price: str
    formatted_current_price_type: str
    location_id: int
    formatted_comparison_price: Optional[str] = None
    formatted_comparison_price_type: Optional[str] = None


class SecondaryAverage(BaseModel):
    id: str
    label: str
    value: float


class Rating(BaseModel):
    average: float
    count: int
    secondary_averages: Optional[List[SecondaryAverage]] = None


class Statistics(BaseModel):
    rating: Rating


class RatingsAndReviews(BaseModel):
    statistics: Statistics


class MerchandiseClassification1(BaseModel):
    class_id: int
    department_id: int


class Images1(BaseModel):
    primary_image_url: str
    alternate_image_urls: List[str]


class VideoFile1(BaseModel):
    mime_type: str
    video_url: str


class Video1(BaseModel):
    is_list_page_eligible: bool
    video_files: List[VideoFile1]


class Enrichment1(BaseModel):
    buy_url: str
    images: Images1
    videos: Optional[List[Video1]] = None


class SoftBullets1(BaseModel):
    bullets: List[str]


class ProductDescription1(BaseModel):
    title: str
    bullet_descriptions: List[str]
    soft_bullets: Optional[SoftBullets1] = None


class PrimaryBrand1(BaseModel):
    canonical_url: str
    facet_id: str
    linking_id: str
    name: str


class Item1(BaseModel):
    relationship_type: str
    relationship_type_code: str
    merchandise_classification: MerchandiseClassification1
    enrichment: Enrichment1
    has_extended_sizing: bool
    cart_add_on_threshold: float
    product_description: ProductDescription1
    primary_brand: PrimaryBrand1


class Price1(BaseModel):
    formatted_current_price: str
    formatted_current_price_type: str
    mixed_current_price_type: Optional[str] = None
    location_id: int
    formatted_comparison_price: Optional[str] = None
    formatted_comparison_price_type: Optional[str] = None


class SecondaryAverage1(BaseModel):
    id: str
    label: str
    value: float


class Rating1(BaseModel):
    average: float
    count: int
    secondary_averages: Optional[List[SecondaryAverage1]] = None


class Statistics1(BaseModel):
    rating: Rating1


class RatingsAndReviews1(BaseModel):
    statistics: Statistics1


class FirstChild(BaseModel):
    tcin: str
    primary_image_url: str
    alternate_image_urls: List[str]
    swatch_image_url: str


class Swatch(BaseModel):
    value: str
    first_child: FirstChild


class Theme(BaseModel):
    name: str
    has_swatch: bool
    swatches: List[Swatch]


class VariationSummary(BaseModel):
    themes: List[Theme]


class Parent(BaseModel):
    __typename: str
    tcin: str
    item: Item1
    promotions: List
    price: Price1
    ratings_and_reviews: RatingsAndReviews1
    variation_summary: VariationSummary


class Product(BaseModel):
    __typename: str
    tcin: Optional[str]
    original_tcin: Optional[str] = None
    item: Optional[Item]
    promotions: Optional[List[Promotion]]
    price: Optional[Price]
    ratings_and_reviews: Optional[RatingsAndReviews] = None
    parent: Optional[Parent] = None


class Search(BaseModel):
    search_suggestions: List[str]
    search_recommendations: Dict[str, Any]
    search_response: SearchResponse
    products: List[Product]


class Data(BaseModel):
    search: Search


class Model(BaseModel):
    data: Data
